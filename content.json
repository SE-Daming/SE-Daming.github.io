[{"title":"索引浅析","date":"2024-10-16T07:01:21.000Z","path":"2024/10/16/索引浅析/","text":"1 索引树的高度如何计算","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://se-daming.github.io/tags/MySQL/"}]},{"title":"SQL优化的几种方式","date":"2024-10-16T06:50:38.000Z","path":"2024/10/16/SQL优化的几种方式/","text":"SQL优化插入优化1、使用批量插入 2、手动提交事务 3、主键顺序插入，减少页分裂和页合并的次数 4、大批量数据使用load命令 主键设计尽量降低主键的长度、主键应当是有序自增的、避免使用UUID或其他业务主键，如身份证、业务操作时尽量不更改主键 为什么不用UUID非递增、太长（36字符）导致占用内存大，索引树的高度大，磁盘IO次数多，性能差 查询优化查询时尽量使用索引查询 索引优化尽量使用覆盖索引、多字段排序时要遵循最左前缀法则、 深度分页延迟关联或子查询优化 group byorder by优化MySQL排序有using index和using filesort两种实现方式，要尽量优化成效率高的using index，避免额外排序 也就是说，要对排序字段创建索引并尽量使用覆盖索引；如果不可避免的出现filesort可以适当增加排序缓冲区的大小 更新优化分批更新、限制更新的行数，避免大事务； 在更新的列上有索引，避免行锁升级为表锁 删除优化大批数据删除要分批次删除，避免大事务阻塞；用LIMIT控制行数 delete和truncate区别delete是DML、truncate是DDL delete删除后可回滚、truncate不能 delete对每一行删除会记录日志，速度慢；truncate不记录，直接释放整个数据页，不支持where条件 delete删除后表的结构属性不变；truncate删除后AUTO-INCREMENT重置 explain关键字 type:连接类型。性能：NULL（select 1） &gt; system （表只有一行、系统表）&gt; const（常量查找，主键或唯一索引） &gt; eq_ref（主键或唯一索引的等值匹配） &gt; ref （非唯一索引的查找）&gt; range（根据索引查找匹配行） &gt; index（扫描整个索引而不是全表扫描） &gt; ALL（全表扫描） 除了ALL都表示用到了索引 key：实际用到的索引 possible_keys：可能用到的索引 rows ：MySQL估计需要读取的行数 extra 额外信息：using index（MySQL仅通过索引来满足查询而无需读取实际数据行）、using where、using filesort（对结果排序时如果索引不能满足则读取实际数据行然后在内存中排序）、using temporary","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://se-daming.github.io/tags/MySQL/"}]},{"title":"设计一个秒杀系统","date":"2024-10-15T04:10:16.000Z","path":"2024/10/15/设计一个秒杀系统/","text":"设计将库存信心保存到redis、利用其抗高并发的特性进行库存的查询和扣减 超卖当买多卖少时，超卖最可能发生 如果允许同一个用户购买多个，则使用redis的decr命令即可、但是会导致库存数为负数。需要在decr返回值小于0时再incr回来以确保超时订单库存回滚正常 如果只允许一个用户购买一个，也就是超买问题 超买判断用户是否购买、判断库存是否充足、扣减库存 其中第二三步redis可解决 判断是否购买放到set集合里面。 分布式环境下就不能放到set、考虑放到redis 原子性MySQL存 ：库存扣了、没有订单 Redis存：数据一致性。redis做了资格判断和扣减库存，没来得及发送到mq操作数据库就挂了","tags":[{"name":"项目","slug":"项目","permalink":"https://se-daming.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"redis单线程，出现阻塞了怎么办","date":"2024-10-15T02:57:26.000Z","path":"2024/10/15/redis单线程，出现阻塞了怎么办/","text":"","tags":[]},{"title":"redis线程模型","date":"2024-10-15T02:20:11.000Z","path":"2024/10/15/redis线程模型/","text":"","tags":[]},{"title":"https连接是如何创建的","date":"2024-10-15T00:49:33.000Z","path":"2024/10/15/https连接是如何创建的/","text":"","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://se-daming.github.io/tags/HTTP/"}]},{"title":"http报文格式是怎样的","date":"2024-10-14T09:42:31.000Z","path":"2024/10/14/http报文格式是怎样的/","text":"请求报文请求行、首部行、空行、请求实体 12345GET /example.com/index.html HTTP1.1Host: www.example.comConnection:closeUser-Agent: Mozilla/5.0Accept-language:CN 响应报文状态行、首部行、空行、相应实体 12345HTTP1.1 200 OKConnection:closeLast-Modified: Tue,18 Aug 2020Cotent-Length:6123Cotent-Type:text/html Connection字段是什么发送完该消息后关闭TCP连接","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://se-daming.github.io/tags/HTTP/"}]},{"title":"http2相对于http1.1到底有哪些改变","date":"2024-10-14T07:58:01.000Z","path":"2024/10/14/http2相对于http1-1到底有哪些改变/","text":"HTTP2的目的减少感知时延，提高响应速度 手段经单一TCP连接使请求和响应多路复用 效果提供报文优先次序、服务器主动推送（如果没发送任何请求，只是建立了TCP连接可以主动推送吗）、首部字段压缩 HTTP1.1存在的问题 HOL 队首阻塞HTTP1使用持续TCP连接，允许经单一TCP连接请求相应一个web页面。这样每个web页面平等共享带宽，导致HOL 假如一个web页面有一个大视频对象和视频下面很多小对象，使用同一TCP连接请求、该大视频会花费很长时间，小对象被延迟了。这就是HOL队首阻塞 HTTP1.1解决HOL打开多个并行TCP连接、web页面的多个对象并行发送给浏览器 HTTP2解决HOL将每个报文分成二进制小帧，并且在同个TCP连接上交错发请求和响应报文，之后在接收端将其组装，这也是HTTP2最为重要的改进 成帧过程主要通过HTTP2的成帧子层完成.当服务器要发送HTTP响应时，该响应首先划分成帧，响应的首部字段成为一帧，报文体成为一帧。通过成帧子层该响应的帧与其他响应的帧交错经过单一TCP连接发送。当帧到达客户端时先在成帧子层组装成初始的响应报文，然后由浏览器处理。类似地、HTTP请求也划分成帧交错发送 服务器推送HTTP1.1中，服务器只是被动响应，浏览器请求什么就响应什么。HTTP2中服务器可以主动推送，即为一个请求发送多个响应，从而消除额外等待时延 首部压缩HTTP2会压缩请求头。如果发送的多个请求的请求头一样或类似。协议会消除重复的部分。这由HPACK算法实现：客户端和服务端同时维护一张头信息表，所有字段会存入这个表，生成一个索引号，以后就只发送索引号不发送字段，从而提高速度 总结HTTP2相对于HTTP1主要提高了响应性能，做了头部压缩、二进制成帧、请求响应多路复用、服务器主动推送","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://se-daming.github.io/tags/HTTP/"}]},{"title":"first","date":"2024-10-14T03:50:05.000Z","path":"2024/10/14/first/","text":"这是我的第一篇博客，加油！haha","tags":[]}]