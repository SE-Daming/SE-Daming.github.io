[{"title":"百度","date":"2024-10-16T15:42:46.000Z","path":"2024/10/16/百度/","text":"基本数据类型 byte1 short2 int4 long8 char2 float4 double8 boolean 面向对象三大特性 封装：通过 public private default protected来实现，主要为了限制其他类和包使用 继承：一个对象可继承自另一个对象 多态：一个变量可有多种表现形态。主要由继承来实现，比如teacher和stu都继承自person，则person既可以表现成stu也可以。。。 重载重写+多态+虚方法表 重载是一个类中有多个方法方法名相同，但是参数或参数类型、返回值不同 重写是当继承自另一个类是，子类重写父类的方法 多态如何实现？ 虚方法表是多态实现的一个必要条件，它记录了方法的实现类的地址，用来确定引用变量调用子类方法时具体调用的哪个方法 集合的几个接口介绍一下，并说区别 集合包含list、set、queue三个主要接口、除此之外还有map list是可重复的一些数据、set是不可重复的数据、map是键值对类型数据的集合 list下包含arraylist、linkedlist、vector的子类实现 set包含hashset、treeset的实现 map包含hashmap、linkedhashmap、hashtable、treemap的实现 ArrayList和LinkedList的区别 底层实现不同：a是动态数组、l是链表 插入和删除效率不同：a的插入需要移动后面元素，时间复杂度是On，删除时也需要移动元素，On l的插入要先找到对应元素然后o1插入，总的来说也是on，删除同理 l更适合在头部插入元素，O1、而a是On a支持索引查找，O1、l是On 大多数情况下使用啊 HashMap一整套（数据结构，扩容） 8之前是数组+链表；8之后是数组+链表+红黑树； 扩容过程:先创建原来2倍容量的数组，然后将旧数组元素拷贝到新的数组，然后改变引用指向新的数组 JMM Volatile 是Java中的一个关键字，用来解决可见性和防止指令重排 当一个变量如果没被volatile标记、则他被修改时可能会先放到缓冲区，其他变量读到的仍然是修改前的数值。 指令重排：JVM会对class文件的命令在不影响结果的前提下进行重排序 Java的锁类型 包含公平锁、分公平锁；可重入锁，不可重入锁 主要包含sync实现的和R锁 sync对比R：非公平、可公可非；不可重入，可重入；修饰代码块、方法， 修饰代码块；自动释放，手动释放；重量、轻量；基于监视器monitor实现，基于AQS实现；R可带超时的获取尝试 AQS的非公平实现（顺便把AQS一整套说了） 线程创建方式（线程和线程体）继承thread类重写run方法；实现runnable接口的run方法；实现callable接口的call方法；线程池创建； 为什么会有线程安全多线程下对同一资源进行操作，比如对同一变量自增，需要先读取然后修改。这个过程不是原子性的，可能出现读到的相同，修改后出现问题 JVM内存模型分为线程共享和线程私有堆内存、运行时常量池；Java虚拟机栈、本地方法栈、程序计数器；字符串常量池 GC算法标记清除、标记复制、标记整理对需要清除的区域先标记再清除；会导致内存碎片问题 将内存区域分为TO、from两部分、对需要清除的区域先标记再将未标记的部分整理到to区，将from指向to；内存利用率不高 先标记需要清除的，然后将其复制到内存一侧；效率不高 垃圾回收器搭配serial，serial oldparaneel、paraneel newserial CMSg1 三色标记算法 CMS,G1CMS是老年代的回收，G1是新生代和老年代；CMS用标记清除算法，G1用标记整理算法CMS：初始标记、并发标记、最终标记、并发清除G1：初始标记、并发标记、并发标记、并发清除CMS会产生内存碎片和浮动垃圾，严重时退化成serial Springboot启动流程 MySQL索引（ACID，事务隔离，MVCC） MySQL锁用来解决并发下的问题全局锁、表级锁、行级锁表锁、元数据锁、意向锁；行锁、间隙锁、临建锁，建立在索引上的，没索引则升级为表锁 MySQL三大日志redolog、undolog、binlog重做日志，用来做崩溃后的恢复；用来事务回滚和MVCC；数据备份用的 MySQL慢SQL排查 假设慢SQL不是索引的问题，可能是哪些原因表数据量过大、考虑分表；表或查询记录被上锁；MySQL抖了一下，刷新脏页到磁盘时 InnoDB的各种特性事务、外键、行级锁、崩溃后数据恢复、mvcc 说一下项目难点，并说说怎么解决 手撕快排","tags":[{"name":"百度日常","slug":"百度日常","permalink":"https://se-daming.github.io/tags/%E7%99%BE%E5%BA%A6%E6%97%A5%E5%B8%B8/"}]},{"title":"分片上传和断点续传如何实现","date":"2024-10-16T14:25:07.000Z","path":"2024/10/16/分片上传和断点续传如何实现/","text":"j用到的技术：Redis、MD5 分片上传前端将文件分片后携带文件id、各个分片的索引，总分片数。文件MD5 后端将总分片数、已经上传的分片保存到redis。当所有分片上传完成后，后端组装这些分片并计算出MD5值验证是否组装成功。 断点续传继续上传时先查询已经上传的分片、从该分片索引处继续上传","tags":[{"name":"实习","slug":"实习","permalink":"https://se-daming.github.io/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"Kafka的架构是怎样的","date":"2024-10-16T10:15:04.000Z","path":"2024/10/16/Kafka的架构是怎样的/","text":"j角色：生产者、broker、消费者","tags":[{"name":"Kafka","slug":"Kafka","permalink":"https://se-daming.github.io/tags/Kafka/"}]},{"title":"ConcurrentHashMap解析","date":"2024-10-16T08:49:34.000Z","path":"2024/10/16/ConcurrentHashMap解析/","text":"1 ConcurrentHashMap的底层结构jdk1.7是数组链表 ，类似于HashMap数组 1.8是数组+链表+红黑树，和HashMap类似 ConcurrentHashMap如何保证线程安全jdk1.8之前包含一个Segment数组（默认是16个，创建后不可更改，最大并发是16）、每一个segment元素都是一个HashEntry数组，类似于HashMap，每一个HashEntry元素是链表 Segment继承了Reentrantlock，是一种可重入锁。每一个segment守护者一个HashEntry数组的元素，要更改元素首先要获取对应的segment锁。 也就是说、同一segment的写会阻塞，不同segment可并发执行 （get要加锁吗） jdk1.8取消了segment分段锁，采用volatile（每个node的value和next）+CAS+sync保证并发安全。 增加元素时先判断容器是否为空。为空则CAS来初始化。否则看元素位置处是否为空，为空则CAS赋值。不为空则sync后遍历赋值 数据结构和hashmap类似，由数组链表红黑树组成。只锁定当前链表或红黑树的首节点来保证并发安全。锁的粒度更小 总结：jdk1.8中通过对头节点加锁来确保线程安全。锁的粒度更小，并发量更大。 为什么要用CAS和Sync计算出该位置处为空则hash碰撞的几率低，用较少的自旋完成put；有元素说明发生了哈希碰撞，有大量线程访问或容量不够了则用悲观锁sync get操作为什么不加锁node的value和next是用volatile修饰的，可以保证可加性","tags":[{"name":"集合","slug":"集合","permalink":"https://se-daming.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"HashMap解析","date":"2024-10-16T08:11:52.000Z","path":"2024/10/16/HashMap解析/","text":"h HashMap的底层原理底层结构是数组、链表、红黑树 HashMap的put流程先看table是否为空，为空则初始化，否则则计算元素下标，如果此处没元素则直接put。如果有则看当前元素是否等于插入元素，等于则覆盖。不等于则遍历链表或红黑树来查找相同的元素，找到则覆盖，找不到则插入到红黑树或链表头部。如果是链表则看是否达到阈值8，达到8且hashmap的数组长度大于64则转换成红黑树；至此插入元素完成，然后检查负载因子是否超过阈值0.75，超过则扩容，否则执行结束 扩容过程先创建一个原数组两倍大小的新数组，将原来的引用指向新数组并更新扩容阈值，将旧数组的元素重新计算哈希码并分配到新数组中， HashMap的get流程计算出元素的索引位置，如果当前位置为null则直接返回，否则看当前元素是否等于k，等于直接返回。否则遍历链表或红黑树直到找到相同的元素；如果不存在则返回null； 为什么线程不安全1、两个线程同时put导致数据丢失。两个元素计算得到的索引一样，并且得到的新插入的位置一样，会导致覆盖其他线程的数据 2、jdk1.8前多线程下扩容会导致死循环 为什么容量是2的n次方1、方便计算索引位置。利用与运算计算代替除运算，更快速的计算出位置。但前提是容量是2的n次方 2、扩容后新数组的位置容易确定，分布比较均匀。扩容中只需判断原hash和左移一位，也就是扩大两倍的hash的与运算是0还是1，0则位置不变，1则原位置加上原容量","tags":[{"name":"集合","slug":"集合","permalink":"https://se-daming.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"索引浅析","date":"2024-10-16T07:01:21.000Z","path":"2024/10/16/索引浅析/","text":"1 索引树的高度如何计算","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://se-daming.github.io/tags/MySQL/"}]},{"title":"SQL优化的几种方式","date":"2024-10-16T06:50:38.000Z","path":"2024/10/16/SQL优化的几种方式/","text":"SQL优化插入优化1、使用批量插入 2、手动提交事务 3、主键顺序插入，减少页分裂和页合并的次数 4、大批量数据使用load命令 主键设计尽量降低主键的长度、主键应当是有序自增的、避免使用UUID或其他业务主键，如身份证、业务操作时尽量不更改主键 为什么不用UUID非递增、太长（36字符）导致占用内存大，索引树的高度大，磁盘IO次数多，性能差 查询优化查询时尽量使用索引查询 索引优化尽量使用覆盖索引、多字段排序时要遵循最左前缀法则、 深度分页延迟关联或子查询优化 group byorder by优化MySQL排序有using index和using filesort两种实现方式，要尽量优化成效率高的using index，避免额外排序 也就是说，要对排序字段创建索引并尽量使用覆盖索引；如果不可避免的出现filesort可以适当增加排序缓冲区的大小 更新优化分批更新、限制更新的行数，避免大事务； 在更新的列上有索引，避免行锁升级为表锁 删除优化大批数据删除要分批次删除，避免大事务阻塞；用LIMIT控制行数 delete和truncate区别delete是DML、truncate是DDL delete删除后可回滚、truncate不能 delete对每一行删除会记录日志，速度慢；truncate不记录，直接释放整个数据页，不支持where条件 delete删除后表的结构属性不变；truncate删除后AUTO-INCREMENT重置 explain关键字 type:连接类型。性能：NULL（select 1） &gt; system （表只有一行、系统表）&gt; const（常量查找，主键或唯一索引） &gt; eq_ref（主键或唯一索引的等值匹配） &gt; ref （非唯一索引的查找）&gt; range（根据索引查找匹配行） &gt; index（扫描整个索引而不是全表扫描） &gt; ALL（全表扫描） 除了ALL都表示用到了索引 key：实际用到的索引 possible_keys：可能用到的索引 rows ：MySQL估计需要读取的行数 extra 额外信息：using index（MySQL仅通过索引来满足查询而无需读取实际数据行）、using where、using filesort（对结果排序时如果索引不能满足则读取实际数据行然后在内存中排序）、using temporary","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://se-daming.github.io/tags/MySQL/"}]},{"title":"设计一个秒杀系统","date":"2024-10-15T04:10:16.000Z","path":"2024/10/15/设计一个秒杀系统/","text":"设计将库存信心保存到redis、利用其抗高并发的特性进行库存的查询和扣减 超卖当买多卖少时，超卖最可能发生 如果允许同一个用户购买多个，则使用redis的decr命令即可、但是会导致库存数为负数。需要在decr返回值小于0时再incr回来以确保超时订单库存回滚正常 如果只允许一个用户购买一个，也就是超买问题 超买判断用户是否购买、判断库存是否充足、扣减库存 其中第二三步redis可解决 判断是否购买放到set集合里面。 分布式环境下就不能放到set、考虑放到redis 原子性MySQL存 ：库存扣了、没有订单 Redis存：数据一致性。redis做了资格判断和扣减库存，没来得及发送到mq操作数据库就挂了","tags":[{"name":"项目","slug":"项目","permalink":"https://se-daming.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"redis单线程，出现阻塞了怎么办","date":"2024-10-15T02:57:26.000Z","path":"2024/10/15/redis单线程，出现阻塞了怎么办/","text":"","tags":[]},{"title":"redis线程模型","date":"2024-10-15T02:20:11.000Z","path":"2024/10/15/redis线程模型/","text":"","tags":[]},{"title":"https连接是如何创建的","date":"2024-10-15T00:49:33.000Z","path":"2024/10/15/https连接是如何创建的/","text":"https握手过程hhttps在建立TCP连接后会进行TLS连接，主要涉及四次握手 客户端发送Client hello请求给服务端，携带支持的TLS版本、一个随机数、（加密）密码套件列表 服务端响应Server hello，携带确认的TLS版本，一个随机数，server端安全证书，确认的密码套件 客户端收到响应后先确认CA证书的真实性如果没问题则从证书中取出公钥然后用它加密报文发送：一个随机数、加密通信算法改变通知（表示以后的通信都用会话密钥加密）、客户端握手阶段结束。客户端根据这三个随机数计算出会话密钥 服务端收到第三个随机数后通过协商的加密算法计算出会话密钥，向客户端发送：加密算法改变通知、服务端握手结束 HTTP VS https端口不同、80 443 https在建立TCP连接轴要经过TLS&#x2F;SSL握手过程再建立http连接 https是加密传输、http是明文传输 https要额外申请CA证书","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://se-daming.github.io/tags/HTTP/"}]},{"title":"http报文格式是怎样的","date":"2024-10-14T09:42:31.000Z","path":"2024/10/14/http报文格式是怎样的/","text":"请求报文请求行、首部行、空行、请求实体 12345GET /example.com/index.html HTTP1.1Host: www.example.comConnection:closeUser-Agent: Mozilla/5.0Accept-language:CN 响应报文状态行、首部行、空行、相应实体 12345HTTP1.1 200 OKConnection:closeLast-Modified: Tue,18 Aug 2020Cotent-Length:6123Cotent-Type:text/html Connection字段是什么发送完该消息后关闭TCP连接","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://se-daming.github.io/tags/HTTP/"}]},{"title":"http2相对于http1.1到底有哪些改变","date":"2024-10-14T07:58:01.000Z","path":"2024/10/14/http2相对于http1-1到底有哪些改变/","text":"HTTP2的目的减少感知时延，提高响应速度 手段经单一TCP连接使请求和响应多路复用 效果提供报文优先次序、服务器主动推送（如果没发送任何请求，只是建立了TCP连接可以主动推送吗）、首部字段压缩 HTTP1.1存在的问题 HOL 队首阻塞HTTP1使用持续TCP连接，允许经单一TCP连接请求相应一个web页面。这样每个web页面平等共享带宽，导致HOL 假如一个web页面有一个大视频对象和视频下面很多小对象，使用同一TCP连接请求、该大视频会花费很长时间，小对象被延迟了。这就是HOL队首阻塞 HTTP1.1解决HOL打开多个并行TCP连接、web页面的多个对象并行发送给浏览器 HTTP2解决HOL将每个报文分成二进制小帧，并且在同个TCP连接上交错发请求和响应报文，之后在接收端将其组装，这也是HTTP2最为重要的改进 成帧过程主要通过HTTP2的成帧子层完成.当服务器要发送HTTP响应时，该响应首先划分成帧，响应的首部字段成为一帧，报文体成为一帧。通过成帧子层该响应的帧与其他响应的帧交错经过单一TCP连接发送。当帧到达客户端时先在成帧子层组装成初始的响应报文，然后由浏览器处理。类似地、HTTP请求也划分成帧交错发送 服务器推送HTTP1.1中，服务器只是被动响应，浏览器请求什么就响应什么。HTTP2中服务器可以主动推送，即为一个请求发送多个响应，从而消除额外等待时延 首部压缩HTTP2会压缩请求头。如果发送的多个请求的请求头一样或类似。协议会消除重复的部分。这由HPACK算法实现：客户端和服务端同时维护一张头信息表，所有字段会存入这个表，生成一个索引号，以后就只发送索引号不发送字段，从而提高速度 总结HTTP2相对于HTTP1主要提高了响应性能，做了头部压缩、二进制成帧、请求响应多路复用、服务器主动推送","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://se-daming.github.io/tags/HTTP/"}]},{"title":"first","date":"2024-10-14T03:50:05.000Z","path":"2024/10/14/first/","text":"这是我的第一篇博客，加油！haha","tags":[]}]